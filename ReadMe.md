# Описание

#### Аннотация
В работе рассматривается задача классификации пакетов в рамках архитектуры отечественного сетевого процессорного устройства(СПУ).
В рамках работы проведен обзор структур данных, используемых для классификации структур данных. На основе выбранных структур данных были реализованы адаптированные под рассматриваемую архитектуру СПУ деревья. Экспериментальное исследование реализованных структур данных, было проведено на имитационной модели СПУ. В качестве вычислительных ядер конвейра СПУ использовались ядра архитектуы RISC-V.

#### Цель работы:
Целью работы является разработка структуры данных для поиска в таблицах классификации в рамках архитектуры СПУ. Для достижения данной цели необходимо решить следующие подзадачи:
1. Изучить существующие структуры данных для поиска в таблицах классификации пакетов для использования в рассматриваемой архитектуре сетевого процессорного устройства.
2. Адаптировать выбранные структуры данных для реализации в рамках рассматриваемой архитектуры сетевого процессора.
3. Реализовать адаптированные структуры данных и алгоритмы поиска.
4. Провести экспериментальное исследование реализованных структур данных.

#### Рассмотренные типы структур
- Trie
- Compressed
- Scalar
- Range


#### Основная Функциональность

Реализованы основные функции insert_in_compressed_tree, delete_from_compressed_tree и search_in_compressed_tree для добавления, удавления вершины из древовидной структуры и поиска элемента в ней. Такие же функции реализованы и для других древовидных структур.


#### Экспериментальные исследования

В работе использовался комплилятор riscv-gnu-toolchain. Это кросс-компилятор RISC-V C и C++. 
Он поддерживает два режима сборки: общий набор инструментов ELF / Newlib и более сложный набор инструментов Linux-ELF / glibc.
Компилятор запускался в QEMU с архитектурой RISC-V.

Компиляция программ осущуствлялась командной riscv-gcc <nameProg>.c -o <nameFile
Запуск командой qemu-riscv64 <nameFile>. Получал информацию RSS с помощью ps -aux –sort -rss | grep <nameFile>. 
Для компиляции использовался компилятор riscv64 riscv-gcc, а запуск производился на эмуляции архитектуры RISC-V в эмуляторе QEMU qemu-riscv64.

#### Выводы
Лучшие показатели изменяемых таблиц маршрутизации имеет сжатое скалярное дерево. При тестировании оно обошло скалярное дерево из-за одинакового количества памяти, выделяемого при создании объекта обеих структур. Но сами деревья имеют разное количество вершин, поэтому сжатое дерево и занимает меньше памяти.


Если же таблицы маршрутизации статичны и меняются очень редко, то лучшим решением будет создание кучи на основе интервального дерева. То есть, сначала создать интервльное дерево, поместить в него нужные записи и перенести информацию оттуда в кучу. Дальнейшее хранение дерева бесполезно. Тем самым имеем какое-то множество ограниченных массивов, которые создаются лишь раз и для их создания вообще не нужна динамическая память. Данный подход будет занимать наименьшее количество памяти по сравнению со всеми остальными.



